
◎ 선형정렬 3종 구현 원리 조사
	
	기본적으로 선형정렬은 구현이 간단하지만 비효율적인 방법

   선택 정렬 : 선택 정렬은 리스트에서 가장 작거나 큰 항목을 찾아 첫 번째 항복과 위치를 바꾼다.
			그리고 나서 다음 항목을 찾아 두 번째 항목과 위치를 바꾼다. 이러한 방식으로 리스트의 끝까지 과정을 반복한다.
			리스트가 이미 정렬이 되어있더라도 시간복잡도는 O(n^2)이며 안정적 이지않다.
			같은 레코드의 값이 있는 경우에는 같은 레코드를 가지고 있는 값들의 위치가 변경 될 수 있다.

			https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html << 선택 정렬 참조 링크

   삽입 정렬 : 데이터를 하나씩 꺼내어 정렬된 자료 중 적합한 위치에 삽입하여 정렬 하는 방식이다.
			 데이터 크기가 작고 리스트가 이미 정렬되어 있으면 병합정렬이나 퀵 정렬 같은 고급 알고리즘보다 성능이 더 좋다.
			 따라서 미리 정렬된 리스트에 새 항목을 추가할 때 쓰면 좋다. 많은 레코들의 이동을 포함하기 때문에 레코드 수가 많고 레코드의 크기가 클 경우에 적합하지 않다.
			 정렬 방법은 n번째 정렬일 경우 n+1 번째 인덱스 항목부터 첫 번째 항목까지 검색하며 바로 옆 항목과 비교하여 더 작은 수를 왼쪽으로 보내준다.
			 시간복잡도는 최선의 경우(입력자료가 완벽하게 정순인 경우) = O(n)이며 최악의 경우(입력자료가 역순일 경우) = O(n^2)

			 https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html << 삽입 정렬 링크

   버블 정렬 : 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘으로 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어있지 않으면 서로 교환하는 방식
			 선택정렬과 유사하다.
			 버블 정렬은 n번째 자료부터 마지막 n-1 자료까지 비교하여 교환하면서 자료를 정렬
			 1회전을 수행한 후 가장 큰 자료가 맨 뒤로 이동하며 2회전을 수행 한 후에는 맨뒤에서 두 번쨰 자료까지는 다음 정렬에서 제외 된다.
			 회전을 수행할 때마다 제외되는 데이터가 역순으로 하나씩 증가하는 방식
			 버블 정렬은 구현이 간단하지만 순서에 맞지않는 요소들을 인접한 요소와 교환 해야하며 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 다른 배열요소들과 전부 교환이 되어야한다.
			 버블정렬의 시간복잡도는 모든 경우에 O(n^2)이다.

			 https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html << 버블 정렬 참조 링크

◎ 분할 정복정렬 3종 구현 원리,특징 조사

	분할 정복정렬은 구현이 복잡하지만 프로그래밍적으로 효율적인 방법
	n개의 요소를 재 위치 시키기 위해 n/2 개를 확인하는 정렬
	시간복잡도 = O(nlongn)

	힙 정렬 : 최대 힙 트리나 최소 힙 트리로 구성해 정렬하는 방법으로 내림차순으로 정렬을 할 때에는 최소힙을 구성하고 오름차순으로 정렬을 할 때에는 최대힙으로 구성한다.
			 n개의 노드에 대한 완전 이진트리를 구성하고 루트 노드부터 부모 - 왼쪽 자식 - 오른쪽 자식 노드 순으로 구성한다.
			 1. 최대힙(부모노드가 자식노드보다 큰 트리)을 구성하고 아래부터 루트까지 올라오는 순차적인 구조로 만들어 간다.
			 2. 가장 큰 수(루트에 위치한 노드) 를 가장 작은 수 힙의 최대깊이 최 우측에 있는 노드와 교환을 한다
			 1,2를 계속 반복한다.
			 시간 복잡도는 일반적인경우 O(nlogn)
			 힙 정렬이 가장 유용한 경우는 전체 자료를 정렬하는 것이 아니라 가장 큰 값 몇개만 필요할 때 이다.

			 https://gmlwjd9405.github.io/2018/05/10/algorithm-heap-sort.html << 힙 정렬 링크

	병합 정렬 : 하나의 리스트를 두 개의 균등한 리스트로 분할하고 분할 된 부분을 부분 리스트를 정렬을 한 뒤 두 개의 정렬된 부분의 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법
			   분할 - 정복 - 결합 순으로 알고리즘이 진행되며 실제로 정렬이 이루어지는 단계는 2개의 리스트를 결합하는 과정에서 정렬이 이루어진다.
			   합병 정렬의 단점은 레코드를 배열로 구성할 경우 임시 배열을 필요로 하고, 제자리 정렬이 아니게되며, 
			   레코드들의 크기가 큰 경우에 이동 횟수가 많기 때문에 시간적 낭비를 초래하게된다.
			   장점으로는 안정적인 정렬방법을 구사할 수 있고 데이터의 분포에 영향을 덜 받는다 즉, 입력 데이터가 무엇이든 정렬되는 시간은 동일하게 된다.
			   만약 LinkedList로 구성을 하면, 링크 인덱스만 변경되므로 데이터의 이동은 무시할 수 있을정도로 작아진다. 이 경우 제자리 정렬로 구현을 할 수 있다.
			   크기가 큰 레코드를 정렬 할 경우에 연결리스트 정렬을 사용한다면, 병합정렬은 퀵 정렬을 포함한 다른 어떤 정렬보다 효율적이다.

			 https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html << 병합 정렬 링크
	
	퀵 정렬 : 하나의 리스트를 피벗을 기준으로 두 개의 비 균등한 리스트로 분할을 하고 분할된 부분 리스트를 정렬한 다음에 두 개의 정렬된 부분의 리스트를 합하여 전체가 정렬된 리스트가 되게하는 방법
			 퀵 정렬 역시 병합 정렬과 동일하게 분할 - 정복 - 결합 순으로 알고리즘이 진행되며 하나의 피벗을 기준으로 비균등하게 분할 후 부분배열을 정렬하고 
			 부분 배열의 크기가 충분히 작지 않으면 순환호출을 이용하여 다시 분할 정복 방법을 찾는다.
			 그 후 정렬된 부분의 배열들을 하나의 배열에 합병을 한다.
			 순환호출이 한 번 진행될때마다 하나의 피벗은 최종적으로 위치가 정해지므로, 이 퀵 정렬 알고리즘은 반드시 끝난다는 것을 확신 할 수 있다.
			 퀵 정렬 알고리즘의 장점으로는 속도가 빠르며 추가 메모리공간을 필요로 하지 않는다는 장점이 있다.
			 단점으로는 정렬된 리스트에 한해서는 퀵정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.
			 퀵정렬의 불균형 분할을 방지하기 위해 피벗을 선택할때 더 균등하게 분할 할 수 있는 데이터를 선택해야한다( 보통 중간값으로 )

			 https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html



